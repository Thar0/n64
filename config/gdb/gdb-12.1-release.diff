diff --git a/gdb/breakpoint.c b/gdb/breakpoint.c
index a3cfeea6..83df571c 100644
--- a/gdb/breakpoint.c
+++ b/gdb/breakpoint.c
@@ -5452,7 +5452,7 @@ bpstat_stop_status (const address_space *aspace,
     {
       if (bs->breakpoint_at && bs->breakpoint_at->type == bp_shlib_event)
 	{
-	  handle_solib_event ();
+	  handle_solib_event (ws.so_event ());
 	  break;
 	}
     }
diff --git a/gdb/infcmd.c b/gdb/infcmd.c
index 682bebe1..b263c3a2 100644
--- a/gdb/infcmd.c
+++ b/gdb/infcmd.c
@@ -288,7 +288,7 @@ post_create_inferior (int from_tty)
 	  /* If the solist is global across processes, there's no need to
 	     refetch it here.  */
 	  if (!gdbarch_has_global_solist (target_gdbarch ()))
-	    solib_add (NULL, 0, auto_solib_add);
+	    solib_add (NULL, 0, auto_solib_add, NULL);
 	}
     }
 
diff --git a/gdb/infrun.c b/gdb/infrun.c
index 5311822f..393c7a3a 100644
--- a/gdb/infrun.c
+++ b/gdb/infrun.c
@@ -5284,7 +5284,7 @@ handle_inferior_event (struct execution_control_state *ecs)
 
 	    regcache = get_thread_regcache (ecs->event_thread);
 
-	    handle_solib_event ();
+	    handle_solib_event (ecs->ws.so_event ());
 
 	    ecs->event_thread->set_stop_pc (regcache_read_pc (regcache));
 	    ecs->event_thread->control.stop_bpstat
diff --git a/gdb/remote.c b/gdb/remote.c
index aa6a67a9..4b7d8a44 100644
--- a/gdb/remote.c
+++ b/gdb/remote.c
@@ -4831,7 +4831,7 @@ remote_target::start_remote_1 (int from_tty, int extended_p)
   /* On OSs where the list of libraries is global to all
      processes, we fetch them early.  */
   if (gdbarch_has_global_solist (target_gdbarch ()))
-    solib_add (NULL, from_tty, auto_solib_add);
+    solib_add (NULL, from_tty, auto_solib_add, NULL);
 
   if (target_is_non_stop_p ())
     {
@@ -7601,7 +7601,9 @@ Packet: '%s'\n"),
 	    }
 	  else if (strprefix (p, p1, "library"))
 	    {
-	      event->ws.set_loaded ();
+	      target_so_event *so_event = solib_parse_event (p1 + 1);
+
+	      event->ws.set_loaded (so_event);
 	      p = strchrnul (p1 + 1, ';');
 	    }
 	  else if (strprefix (p, p1, "replaylog"))
diff --git a/gdb/solib-svr4.c b/gdb/solib-svr4.c
index 69f2991f..89471601 100644
--- a/gdb/solib-svr4.c
+++ b/gdb/solib-svr4.c
@@ -1447,7 +1447,7 @@ svr4_fetch_objfile_link_map (struct objfile *objfile)
 
   /* Cause svr4_current_sos() to be run if it hasn't been already.  */
   if (info->main_lm_addr == 0)
-    solib_add (NULL, 0, auto_solib_add);
+    solib_add (NULL, 0, auto_solib_add, NULL);
 
   /* svr4_current_sos() will set main_lm_addr for the main executable.  */
   if (objfile == current_program_space->symfile_object_file)
@@ -1773,7 +1773,7 @@ disable_probes_interface (svr4_info *info)
    standard interface.  */
 
 static void
-svr4_handle_solib_event (void)
+svr4_handle_solib_event (target_so_event *so_event)
 {
   struct svr4_info *info = get_svr4_info (current_program_space);
   struct probe_and_action *pa;
@@ -2129,7 +2129,7 @@ enable_break (struct svr4_info *info, int from_tty)
      mean r_brk has already been relocated.  Assume the dynamic linker
      is the object containing r_brk.  */
 
-  solib_add (NULL, from_tty, auto_solib_add);
+  solib_add (NULL, from_tty, auto_solib_add, NULL);
   sym_addr = 0;
   if (info->debug_base && solib_svr4_r_map (info) != 0)
     sym_addr = solib_svr4_r_brk (info);
@@ -2301,7 +2301,7 @@ enable_break (struct svr4_info *info, int from_tty)
 	  info->debug_loader_name = xstrdup (interp_name);
 	  info->debug_loader_offset_p = 1;
 	  info->debug_loader_offset = load_addr;
-	  solib_add (NULL, from_tty, auto_solib_add);
+	  solib_add (NULL, from_tty, auto_solib_add, NULL);
 	}
 
       /* Record the relocated start and end address of the dynamic linker
diff --git a/gdb/solib-target.c b/gdb/solib-target.c
index 54b98243..f74509c9 100644
--- a/gdb/solib-target.c
+++ b/gdb/solib-target.c
@@ -25,7 +25,9 @@
 #include "target.h"
 #include "solib-target.h"
 #include <vector>
+#include <memory>
 #include "inferior.h"
+#include "gdbsupport/rsp-low.h"
 
 /* Private data for each loaded library.  */
 struct lm_info_target : public lm_info_base
@@ -275,6 +277,80 @@ solib_target_current_sos (void)
   return start;
 }
 
+static target_so_event *
+solib_target_parse_so_event (const char *p)
+{
+  if (*p != '+' && *p != '-')
+    return NULL;
+
+  std::unique_ptr<target_so_event> so_event (new target_so_event ());
+
+  while (*p == '+' || *p == '-')
+    {
+      struct so_list **so_link;
+
+      if (*p++ == '+')
+        so_link = &so_event->loaded_sos;
+      else
+        so_link = &so_event->unloaded_sos;
+
+      const char *name = p;
+      size_t name_length = 0;
+      while (*p != '\0' && *p != ',' && *p != ';')
+	{
+	  p++;
+	  name_length++;
+	}
+
+      if (name_length == 0)
+        return NULL;
+
+      if (name_length > SO_NAME_MAX_PATH_SIZE - 1)
+        continue;
+
+      std::unique_ptr<so_list, so_deleter> so (XCNEW (so_list));
+
+      memcpy (so->so_name, name, name_length);
+      so->so_name[name_length] = '\0';
+
+      memcpy (so->so_original_name, name, name_length);
+      so->so_original_name[name_length] = '\0';
+
+      lm_info_target *info = new lm_info_target ();
+      so->lm_info = info;
+
+      if (*p == ',')
+	{
+	  p++;
+
+	  char offset_type = *p++;
+	  std::vector<CORE_ADDR> *offset_vec;
+
+	  if (offset_type == 'S')
+	    offset_vec = &info->segment_bases;
+	  else if (offset_type == 's')
+	    offset_vec = &info->section_bases;
+	  else
+	    return NULL;
+
+	  while (*p == ',')
+	    {
+	      ULONGEST address = 0;
+	      p = unpack_varlen_hex (++p, &address);
+	      offset_vec->push_back (address);
+	    }
+	}
+
+      so->next = *so_link;
+      *so_link = so.release ();
+    }
+
+  if (*p != ';')
+    return NULL;
+
+  return so_event.release ();
+}
+
 static void
 solib_target_solib_create_inferior_hook (int from_tty)
 {
@@ -448,6 +524,7 @@ _initialize_solib_target ()
   solib_target_so_ops.solib_create_inferior_hook
     = solib_target_solib_create_inferior_hook;
   solib_target_so_ops.current_sos = solib_target_current_sos;
+  solib_target_so_ops.parse_so_event = solib_target_parse_so_event;
   solib_target_so_ops.open_symbol_file_object
     = solib_target_open_symbol_file_object;
   solib_target_so_ops.in_dynsym_resolve_code
diff --git a/gdb/solib.c b/gdb/solib.c
index b9b1d037..b171a6d3 100644
--- a/gdb/solib.c
+++ b/gdb/solib.c
@@ -898,6 +898,190 @@ Do you need \"set solib-search-path\" or \"set sysroot\"?"),
     }
 }
 
+void
+update_solib_list_from_event (target_so_event *so_event, int from_tty)
+{
+  const struct target_so_ops *ops = solib_ops (target_gdbarch ());
+  struct so_list *gdb, **gdb_link;
+
+  /* We can reach here due to changing solib-search-path or the
+     sysroot, before having any inferior.  */
+  if (target_has_execution () && inferior_ptid != null_ptid)
+    {
+      struct inferior *inf = current_inferior ();
+
+      /* If we are attaching to a running process for which we
+	 have not opened a symbol file, we may be able to get its
+	 symbols now!  */
+      if (inf->attach_flag
+	  && current_program_space->symfile_object_file == NULL)
+	{
+	  try
+	    {
+	      ops->open_symbol_file_object (from_tty);
+	    }
+	  catch (const gdb_exception &ex)
+	    {
+	      exception_fprintf (gdb_stderr, ex,
+				 "Error reading attached "
+				 "process's symbol file.\n");
+	    }
+	}
+    }
+
+  gdb = current_program_space->so_list;
+  gdb_link = &current_program_space->so_list;
+  while (gdb)
+    {
+      struct so_list *l = so_event->loaded_sos;
+      struct so_list **l_link = &so_event->loaded_sos;
+
+      struct so_list *u = so_event->unloaded_sos;
+      struct so_list **u_link = &so_event->unloaded_sos;
+
+      /* Check to see whether the shared object *gdb also appears in
+	 the events's lists.  */
+      while (l)
+	{
+	  if (ops->same)
+	    {
+	      if (ops->same (gdb, l))
+		break;
+	    }
+	  else
+	    {
+	      if (! filename_cmp (gdb->so_original_name, l->so_original_name))
+		break;
+	    }
+
+	  l_link = &l->next;
+	  l = *l_link;
+	}
+
+      while (u)
+	{
+	  if (ops->same)
+	    {
+	      if (ops->same (gdb, u))
+		break;
+	    }
+	  else
+	    {
+	      if (! filename_cmp (gdb->so_original_name, u->so_original_name))
+		break;
+	    }
+
+	  u_link = &u->next;
+	  u = *u_link;
+	}
+
+      /* If the shared object appears on both the event's loaded list
+	 and GDB's list, we don't need to do anything.  Delete it from
+	 the event's list and leave it on GDB's list.  */
+      if (l)
+	{
+	  *l_link = l->next;
+	  free_so (l);
+	}
+
+      /* If the shared object appears on both the event's unloaded list
+	 and GDB's list, delete it from both lists.  */
+      if (u)
+	{
+	  *u_link = u->next;
+	  free_so (u);
+
+	  /* Notify any observer that the shared object has been
+	     unloaded before we remove it from GDB's tables.  */
+	  gdb::observers::solib_unloaded.notify (gdb);
+
+	  current_program_space->deleted_solibs.push_back (gdb->so_name);
+
+	  *gdb_link = gdb->next;
+
+	  /* Unless the user loaded it explicitly, free SO's objfile.  */
+	  if (gdb->objfile && ! (gdb->objfile->flags & OBJF_USERLOADED)
+	      && !solib_used (gdb))
+	    gdb->objfile->unlink ();
+
+	  /* Some targets' section tables might be referring to
+	     sections from so->abfd; remove them.  */
+	  current_program_space->remove_target_sections (gdb);
+
+	  free_so (gdb);
+	  gdb = *gdb_link;
+	}
+      else
+	{
+	  gdb_link = &gdb->next;
+	  gdb = *gdb_link;
+	}
+    }
+
+  /* Now the event's loaded list contains only shared objects that don't
+     appear in GDB's list --- those that are newly loaded.  Add them
+     to GDB's shared object list.  */
+  if (so_event->loaded_sos)
+    {
+      int not_found = 0;
+      const char *not_found_filename = NULL;
+
+      struct so_list *i;
+
+      /* Move the new shared objects to GDB's list.  */
+      *gdb_link = so_event->loaded_sos;
+      so_event->loaded_sos = NULL;
+
+      /* Fill in the rest of each of the `struct so_list' nodes.  */
+      for (i = *gdb_link; i; i = i->next)
+	{
+
+	  i->pspace = current_program_space;
+	  current_program_space->added_solibs.push_back (i);
+
+	  try
+	    {
+	      /* Fill in the rest of the `struct so_list' node.  */
+	      if (!solib_map_sections (i))
+		{
+		  not_found++;
+		  if (not_found_filename == NULL)
+		    not_found_filename = i->so_original_name;
+		}
+	    }
+
+	  catch (const gdb_exception_error &e)
+	    {
+	      exception_fprintf (gdb_stderr, e,
+				 _("Error while mapping shared "
+				   "library sections:\n"));
+	    }
+
+	  /* Notify any observer that the shared object has been
+	     loaded now that we've added it to GDB's tables.  */
+	  gdb::observers::solib_loaded.notify (i);
+	}
+
+      /* If a library was not found, issue an appropriate warning
+	 message.  We have to use a single call to warning in case the
+	 front end does something special with warnings, e.g., pop up
+	 a dialog box.  It Would Be Nice if we could get a "warning: "
+	 prefix on each line in the CLI front end, though - it doesn't
+	 stand out well.  */
+
+      if (not_found == 1)
+	warning (_("Could not load shared library symbols for %s.\n"
+		   "Do you need \"set solib-search-path\" "
+		   "or \"set sysroot\"?"),
+		 not_found_filename);
+      else if (not_found > 1)
+	warning (_("\
+Could not load shared library symbols for %d libraries, e.g. %s.\n\
+Use the \"info sharedlibrary\" command to see the complete listing.\n\
+Do you need \"set solib-search-path\" or \"set sysroot\"?"),
+		 not_found, not_found_filename);
+    }
+}
 
 /* Return non-zero if NAME is the libpthread shared library.
 
@@ -934,7 +1118,8 @@ libpthread_solib_p (struct so_list *so)
    FROM_TTY is described for update_solib_list, above.  */
 
 void
-solib_add (const char *pattern, int from_tty, int readsyms)
+solib_add (const char *pattern, int from_tty, int readsyms,
+	   target_so_event *so_event)
 {
   if (print_symbol_loading_p (from_tty, 0, 0))
     {
@@ -957,7 +1142,10 @@ solib_add (const char *pattern, int from_tty, int readsyms)
 	error (_("Invalid regexp: %s"), re_err);
     }
 
-  update_solib_list (from_tty);
+  if (so_event)
+    update_solib_list_from_event (so_event, from_tty);
+  else
+    update_solib_list (from_tty);
 
   /* Walk the list of currently loaded shared libraries, and read
      symbols for any that match the pattern --- or any whose symbols
@@ -1203,6 +1391,17 @@ solib_create_inferior_hook (int from_tty)
   ops->solib_create_inferior_hook (from_tty);
 }
 
+target_so_event *
+solib_parse_event (const char *p)
+{
+  const struct target_so_ops *ops = solib_ops (target_gdbarch ());
+
+  if (ops->parse_so_event)
+    return ops->parse_so_event (p);
+  else
+    return NULL;
+}
+
 /* See solib.h.  */
 
 bool
@@ -1219,7 +1418,7 @@ static void
 sharedlibrary_command (const char *args, int from_tty)
 {
   dont_repeat ();
-  solib_add (args, from_tty, 1);
+  solib_add (args, from_tty, 1, NULL);
 }
 
 /* Implements the command "nosharedlibrary", which discards symbols
@@ -1253,12 +1452,12 @@ update_solib_breakpoints (void)
 /* See solib.h.  */
 
 void
-handle_solib_event (void)
+handle_solib_event (target_so_event *so_event)
 {
   const struct target_so_ops *ops = solib_ops (target_gdbarch ());
 
   if (ops->handle_event != NULL)
-    ops->handle_event ();
+    ops->handle_event (so_event);
 
   current_inferior ()->pspace->clear_solib_cache ();
 
@@ -1266,7 +1465,7 @@ handle_solib_event (void)
      be adding them automatically.  Switch terminal for any messages
      produced by breakpoint_re_set.  */
   target_terminal::ours_for_output ();
-  solib_add (NULL, 0, auto_solib_add);
+  solib_add (NULL, 0, auto_solib_add, so_event);
   target_terminal::inferior ();
 }
 
@@ -1375,7 +1574,7 @@ reload_shared_libraries (const char *ignored, int from_tty,
      removed.  Call it only after the solib target has been initialized by
      solib_create_inferior_hook.  */
 
-  solib_add (NULL, 0, auto_solib_add);
+  solib_add (NULL, 0, auto_solib_add, NULL);
 
   breakpoint_re_set ();
 
diff --git a/gdb/solib.h b/gdb/solib.h
index 2258b0ba..28d057a0 100644
--- a/gdb/solib.h
+++ b/gdb/solib.h
@@ -25,6 +25,7 @@ struct so_list;
 struct target_ops;
 struct target_so_ops;
 struct program_space;
+struct target_so_event;
 
 #include "symfile-add-flags.h"
 
@@ -35,7 +36,7 @@ extern void clear_solib (void);
 
 /* Called to add symbols from a shared library to gdb's symbol table.  */
 
-extern void solib_add (const char *, int, int);
+extern void solib_add (const char *, int, int, target_so_event *so_event);
 extern bool solib_read_symbols (struct so_list *, symfile_add_flags);
 
 /* Function to be called when the inferior starts up, to discover the
@@ -45,6 +46,8 @@ extern bool solib_read_symbols (struct so_list *, symfile_add_flags);
 
 extern void solib_create_inferior_hook (int from_tty);
 
+extern target_so_event *solib_parse_event (const char *p);
+
 /* If ADDR lies in a shared library, return its name.  */
 
 extern char *solib_name_from_address (struct program_space *, CORE_ADDR);
@@ -93,6 +96,9 @@ extern void set_solib_ops (struct gdbarch *gdbarch,
 
 extern void update_solib_list (int from_tty);
 
+extern void update_solib_list_from_event (target_so_event *so_event,
+					  int from_tty);
+
 /* Return true if NAME is the libpthread shared library.  */
 
 extern bool libpthread_name_p (const char *name);
@@ -124,6 +130,6 @@ extern void update_solib_breakpoints (void);
 
 /* Handle an solib event by calling solib_add.  */
 
-extern void handle_solib_event (void);
+extern void handle_solib_event (target_so_event *so_event);
 
 #endif /* SOLIB_H */
diff --git a/gdb/solist.h b/gdb/solist.h
index 34198dc0..ed694b23 100644
--- a/gdb/solist.h
+++ b/gdb/solist.h
@@ -31,6 +31,8 @@ struct lm_info_base
 {
 };
 
+struct target_so_event;
+
 struct so_list
 {
   /* The following fields of the structure come directly from the
@@ -115,6 +117,8 @@ struct target_so_ops
      we provide values for.  */
   struct so_list *(*current_sos) (void);
 
+  target_so_event *(*parse_so_event) (const char *p);
+
   /* Find, open, and read the symbols for the main executable.  If
      FROM_TTY is non-zero, allow messages to be printed.  */
   int (*open_symbol_file_object) (int from_ttyp);
@@ -160,7 +164,7 @@ struct target_so_ops
      performed before solib_add is called.  This pointer can be
      NULL, in which case no specific preprocessing is necessary
      for this target.  */
-  void (*handle_event) (void);
+  void (*handle_event) (target_so_event *so_event);
 };
 
 using so_list_range = next_range<so_list>;
diff --git a/gdb/target/waitstatus.h b/gdb/target/waitstatus.h
index 7b5faed8..0a529985 100644
--- a/gdb/target/waitstatus.h
+++ b/gdb/target/waitstatus.h
@@ -22,6 +22,8 @@
 
 #include "diagnostics.h"
 #include "gdbsupport/gdb_signals.h"
+#include <memory>
+#include "solist.h"
 
 /* Stuff for target_wait.  */
 
@@ -151,6 +153,33 @@ DIAGNOSTIC_POP
   gdb_assert_not_reached ("invalid target_waitkind value: %d\n", (int) kind);
 }
 
+struct target_so_event
+{
+  target_so_event () = default;
+
+  ~target_so_event ()
+  {
+    while (loaded_sos)
+      {
+	struct so_list *so = loaded_sos;
+	loaded_sos = so->next;
+
+	free_so (so);
+      }
+
+    while (unloaded_sos)
+      {
+	struct so_list *so = unloaded_sos;
+	unloaded_sos = so->next;
+
+	free_so (so);
+      }
+  }
+
+  struct so_list *loaded_sos = nullptr;
+  struct so_list *unloaded_sos = nullptr;
+};
+
 struct target_waitstatus
 {
   /* Default constructor.  */
@@ -162,6 +191,7 @@ struct target_waitstatus
   {
     m_kind = other.m_kind;
     m_value = other.m_value;
+    m_so_event = other.m_so_event;
 
     if (m_kind == TARGET_WAITKIND_EXECD)
       m_value.execd_pathname = xstrdup (m_value.execd_pathname);
@@ -173,6 +203,7 @@ struct target_waitstatus
   {
     m_kind = other.m_kind;
     m_value = other.m_value;
+    m_so_event = other.m_so_event;
 
     if (m_kind == TARGET_WAITKIND_EXECD)
       other.m_value.execd_pathname = nullptr;
@@ -187,6 +218,7 @@ struct target_waitstatus
     this->reset ();
     m_kind = rhs.m_kind;
     m_value = rhs.m_value;
+    m_so_event = rhs.m_so_event;
 
     if (m_kind == TARGET_WAITKIND_EXECD)
       m_value.execd_pathname = xstrdup (m_value.execd_pathname);
@@ -201,6 +233,7 @@ struct target_waitstatus
     this->reset ();
     m_kind = rhs.m_kind;
     m_value = rhs.m_value;
+    m_so_event = rhs.m_so_event;
 
     if (m_kind == TARGET_WAITKIND_EXECD)
       rhs.m_value.execd_pathname = nullptr;
@@ -243,10 +276,11 @@ struct target_waitstatus
     return *this;
   }
 
-  target_waitstatus &set_loaded ()
+  target_waitstatus &set_loaded (target_so_event *so_event)
   {
     this->reset ();
     m_kind = TARGET_WAITKIND_LOADED;
+    m_so_event.reset(so_event);
     return *this;
   }
 
@@ -387,6 +421,12 @@ struct target_waitstatus
     return m_value.syscall_number;
   }
 
+  target_so_event *so_event () const
+  {
+    gdb_assert (m_kind == TARGET_WAITKIND_LOADED);
+    return m_so_event.get();
+  }
+
   /* Return a pretty printed form of target_waitstatus.
 
      This is only meant to be used in debug messages, not for user-visible
@@ -400,6 +440,8 @@ struct target_waitstatus
     if (m_kind == TARGET_WAITKIND_EXECD)
       xfree (m_value.execd_pathname);
 
+    m_so_event.reset();
+
     m_kind = TARGET_WAITKIND_IGNORE;
   }
 
@@ -419,6 +461,8 @@ struct target_waitstatus
       /* Syscall number */
       int syscall_number;
     } m_value {};
+    /* Solib event information */
+    std::shared_ptr<target_so_event> m_so_event;
 };
 
 /* Extended reasons that can explain why a target/thread stopped for a
