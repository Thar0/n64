diff --git a/bfd/elfxx-mips.c b/bfd/elfxx-mips.c
index e0e23926f03..512e745e826 100644
--- a/bfd/elfxx-mips.c
+++ b/bfd/elfxx-mips.c
@@ -12221,6 +12221,190 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,
   return true;
 }
 
+/* Embedded relocs (z64).  */
+
+/* Size of a single entry in .emreloc  */
+#define EMRELOC_ENTRY_SIZE 4
+
+bfd_size_type
+bfd_mips_elf_calc_embedded_relocs_size (bfd *abfd, struct bfd_link_info *info,
+                                        asection *sec)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Sym *isymbuf = NULL;
+  Elf_Internal_Rela *internal_relocs = NULL;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_size_type size = 0;
+
+  /* To determine the size of the embedded relocs section for the input
+     section, we go through the reloctions for the section and find those
+     that relocate defined symbols only.  Each of these will contribute
+     EMRELOC_ENTRY_SIZE bytes to the embedded relocs section.  Writing is
+     done in bfd_mips_elf_create_embedded_relocs.  */
+
+  if (sec->reloc_count == 0)
+    return 0;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  /* Get a copy of the native relocations.  */
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
+		      info->keep_memory));
+  if (internal_relocs == NULL)
+    goto error_return;
+
+  irelend = internal_relocs + sec->reloc_count;
+  for (irel = internal_relocs; irel < irelend; irel++)
+    {
+      Elf_Internal_Sym *isym;
+
+      /* Read this BFD's local symbols if we haven't done so already.  */
+      if (isymbuf == NULL)
+        {
+	  bfd_size_type n_syms;
+
+	  n_syms = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
+
+	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+	  if (isymbuf == NULL)
+	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+					    n_syms, 0,
+					    NULL, NULL, NULL);
+	  if (isymbuf == NULL)
+	    goto error_return;
+        }
+
+      /* Only output for symbols defined in the input section.  */
+      isym = isymbuf + ELF32_R_SYM (irel->r_info);
+      if (isym->st_shndx != STN_UNDEF)
+        size += EMRELOC_ENTRY_SIZE;
+    }
+
+  if (symtab_hdr->contents != (unsigned char *) isymbuf)
+    free (isymbuf);
+  if (elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+  return size;
+
+ error_return:
+  if (symtab_hdr->contents != (unsigned char *) isymbuf)
+    free (isymbuf);
+  if (elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+  return 0;
+}
+
+bool
+bfd_mips_elf_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
+				     asection *sec, asection *relsec,
+				     char **errmsg)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Sym *isymbuf = NULL;
+  Elf_Internal_Rela *internal_relocs = NULL;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_byte *p;
+
+  // printf("embedded relocs for %s -> %s\n", sec->name, relsec->name);
+
+  // BFD_ASSERT (! bfd_link_relocatable (info));
+
+  *errmsg = NULL;
+
+  if (sec->reloc_count == 0)
+    return true;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  /* Get a copy of the native relocations.  */
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
+		      info->keep_memory));
+  if (internal_relocs == NULL)
+    goto error_return;
+
+  /* Create section contents.  */
+  relsec->contents = (bfd_byte *) bfd_alloc (abfd, relsec->size);
+  if (relsec->contents == NULL)
+    goto error_return;
+
+  p = relsec->contents;
+
+  irelend = internal_relocs + sec->reloc_count;
+  for (irel = internal_relocs; irel < irelend; irel++)
+    {
+      /* We are going to write a four byte longword into the runtime
+       * reloc section.  It hs made up of three components:
+       *  - A 2-bit section "id", limited to 1=.text 2=.data 3=.rodata
+       *  - A 6-bit relocation type, same values as ELF32_R_TYPE
+       *  - A 24-bit offset into the output section to apply this relocation to
+       */
+
+      /* Only output for local symbols.  */
+      Elf_Internal_Sym *isym;
+
+      /* Read this BFD's local symbols if we haven't done so already.  */
+      if (isymbuf == NULL)
+        {
+	  bfd_size_type n_syms;
+
+	  n_syms = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
+
+	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+	  if (isymbuf == NULL)
+	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+					    n_syms, 0,
+					    NULL, NULL, NULL);
+	  if (isymbuf == NULL)
+	    goto error_return;
+        }
+
+      /* Only output for symbols defined in the current bfd.  */
+      isym = isymbuf + ELF32_R_SYM (irel->r_info);
+      if (isym->st_shndx != STN_UNDEF)
+        {
+	  int sec_id = 0;
+
+	  /* Determine section "id" based on output section name.  */
+	  if (!strncmp(sec->output_section->name, ".text", 5))
+	    sec_id = 1;
+	  else if (!strncmp(sec->output_section->name, ".data", 5))
+	    sec_id = 2;
+	  else if (!strncmp(sec->output_section->name, ".rodata", 7))
+	    sec_id = 3;
+
+	  // printf("%s\n", bfd_elf_sym_name(abfd, symtab_hdr, isym, bfd_section_from_elf_index (abfd, isym->st_shndx)));
+#define REL_PACK(id, type, offset) \
+	(((id) << 30) | (((type) & 0x3F) << 24) | ((offset) & 0xFFFFFF))
+
+	  bfd_put_32 (abfd,
+		      REL_PACK(sec_id,
+			ELF32_R_TYPE(irel->r_info),
+			sec->output_offset + irel->r_offset),
+		      p);
+#undef REL_PACK
+	  p += EMRELOC_ENTRY_SIZE;
+        }
+    }
+
+  if (symtab_hdr->contents != (unsigned char *) isymbuf)
+    free (isymbuf);
+  if (elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+  return true;
+
+ error_return:
+  if (symtab_hdr->contents != (unsigned char *) isymbuf)
+    free (isymbuf);
+  if (elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+  return false;
+}
+
+#undef EMRELOC_ENTRY_SIZE
+
+
 
 /* Set ABFD's EF_MIPS_ARCH and EF_MIPS_MACH flags.  */
 
diff --git a/bfd/elfxx-mips.h b/bfd/elfxx-mips.h
index 3be69524c01..712ffb618f8 100644
--- a/bfd/elfxx-mips.h
+++ b/bfd/elfxx-mips.h
@@ -67,6 +67,11 @@ extern bool _bfd_mips_vxworks_finish_dynamic_symbol
    Elf_Internal_Sym *);
 extern bool _bfd_mips_elf_finish_dynamic_sections
   (bfd *, struct bfd_link_info *);
+extern bfd_size_type bfd_mips_elf_calc_embedded_relocs_size
+  (bfd *abfd, struct bfd_link_info *info, asection *sec);
+extern bool bfd_mips_elf_create_embedded_relocs
+  (bfd *abfd, struct bfd_link_info *info,
+   asection *sec, asection *relsec, char **errmsg);
 extern bool _bfd_mips_elf_sort_relocs_p
   (asection *);
 extern void _bfd_mips_final_write_processing
diff --git a/ld/emultempl/mipself.em b/ld/emultempl/mipself.em
index 47df4880ee9..6afeb20da22 100644
--- a/ld/emultempl/mipself.em
+++ b/ld/emultempl/mipself.em
@@ -208,6 +208,74 @@ mips_create_output_section_statements (void)
     }
 }
 
+/* This is called after garbage collection of sections and checking
+   relocations, but before mapping input sections to output sections.  */
+
+static void
+mips_after_check_relocs (void)
+{
+  /* Call the standard elf routine.  */
+  after_check_relocs_default ();
+
+  if (command_line.embedded_relocs)
+    {
+      bfd *abfd;
+
+      /* In the embedded relocs mode we create a .emreloc section for each
+	 allocable, in-memory section.  The BFD backend will fill in these
+	 sections with magic numbers which can be used to relocate the
+	 section at run time.  */
+
+      for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link.next)
+	{
+	  asection *sect;
+
+	  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
+	    einfo (_("%F%P: %pB: all input objects must be ELF "
+		     "for --embedded-relocs\n"));
+
+	  for (sect = abfd->sections; sect != NULL; sect = sect->next)
+	    {
+	      bfd_size_type size;
+	      asection *relsect;
+	      char *relsect_name;
+
+	      if (sect->flags & SEC_EXCLUDE)
+		continue;
+	      if ((sect->flags & (SEC_ALLOC | SEC_HAS_CONTENTS))
+		   != (SEC_ALLOC | SEC_HAS_CONTENTS))
+		continue;
+	      if (sect->reloc_count == 0)
+		continue;
+
+	      size = bfd_mips_elf_calc_embedded_relocs_size (abfd, &link_info,
+							     sect);
+	      if (size == 0)
+		continue;
+
+	      relsect_name = bfd_alloc (abfd,
+					sizeof(".emreloc")
+					 + strlen(sect->name) + 1);
+	      strcpy (relsect_name, ".emreloc");
+	      strcat (relsect_name, sect->name);
+
+	      relsect = bfd_make_section_with_flags (abfd, relsect_name,
+						     (SEC_ALLOC
+						      | SEC_LOAD
+						      | SEC_HAS_CONTENTS
+						      | SEC_IN_MEMORY));
+	      if (relsect == NULL)
+		einfo (_("%F%P: %pB: can not create .emreloc section: %E\n"));
+
+	      relsect->alignment_power = 2;
+	      relsect->size = size;
+
+	      // printf("Created %s, sized %lx\n", relsect_name, relsect->size);
+	    }
+	}
+    }
+}
+
 /* This is called after we have merged the private data of the input bfds.  */
 
 static void
@@ -224,9 +292,76 @@ mips_before_allocation (void)
 	_bfd_mips_elf_use_plts_and_copy_relocs (&link_info);
     }
 
+  /* Call the standard elf routine.  */
   gld${EMULATION_NAME}_before_allocation ();
 }
 
+/* This function is called after the section sizes and offsets have been set.  */
+
+static void
+mips_after_allocation (void)
+{
+  /* Call the standard elf routine.  */
+  gld${EMULATION_NAME}_after_allocation ();
+
+  if (command_line.embedded_relocs)
+    {
+      bfd *abfd;
+
+      /* If we are generating embedded relocs, call a special BFD backend
+	 routine to do the work.  */
+
+      for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link.next)
+	{
+	  asection *sect;
+
+	  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
+	    abort ();
+
+	  for (sect = abfd->sections; sect != NULL; sect = sect->next)
+	    {
+	      asection *relsec;
+	      char *errmsg;
+	      char *relsect_name;
+
+	      if (sect->flags & SEC_EXCLUDE)
+		continue;
+	      if ((sect->flags & (SEC_ALLOC | SEC_HAS_CONTENTS))
+		   != (SEC_ALLOC | SEC_HAS_CONTENTS))
+		continue;
+	      if (sect->reloc_count == 0)
+		continue;
+
+	      relsect_name = malloc (sizeof(".emreloc")
+				      + strlen(sect->name) + 1);
+	      strcpy(relsect_name, ".emreloc");
+	      strcat(relsect_name, sect->name);
+
+	      relsec = bfd_get_section_by_name (abfd, relsect_name);
+
+	      free (relsect_name);
+
+	      if (relsec == NULL)
+		continue;
+
+	      if (! bfd_mips_elf_create_embedded_relocs (abfd, &link_info,
+							 sect, relsec,
+							 &errmsg))
+		{
+		  if (errmsg == NULL)
+		    einfo (_("%X%P: %pB: can not create "
+			     "runtime reloc information: %E\n"),
+			   abfd);
+		  else
+		    einfo (_("%X%P: %pB: can not create "
+			     "runtime reloc information: %s\n"),
+			   abfd, errmsg);
+		}
+	    }
+	}
+    }
+}
+
 EOF
 
 # Define some shell vars to insert bits of code into the standard elf
@@ -302,5 +437,7 @@ PARSE_AND_LIST_ARGS_CASES='
       break;
 '
 
+LDEMUL_AFTER_CHECK_RELOCS=mips_after_check_relocs
 LDEMUL_BEFORE_ALLOCATION=mips_before_allocation
+LDEMUL_AFTER_ALLOCATION=mips_after_allocation
 LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=mips_create_output_section_statements
